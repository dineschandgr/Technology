#Java

#Java editions

1. Java Standard Edition (SE) - for developers
2. Java Enterprise Edition - for Enterprises
3. Micro Edition (ME) - for mobile devices
4. Java Card - for machines like Tv, Fridge, Blue ray etc

#Java compilation process

1. When Java class is compiled using compiler, the byte code is created i.e .class file
2. This byte code can be rone in any environment with the JRE installed
3. The JRE has JVM which converts byte code to the native code
4. Hence Java code is portable and platform independent


#Types

#Variables

- To store temporary data in system memory
- declare only variable in 1 line at a time


#Types

#1. Primitive Types

- to store values

whole number

1. byte
2. short
3. int (int viewsCount = 3_123;)
4. long (long viewsCount1 = 3_123_456_789L;)

decimal number

5. float 
6. double (float price1 = 10.99F;)

7. char type
8. boolean

#2. Reference Types

- to store objects
- we always need to allocate memory for reference types
- JRE allocates the memory
- Point point1 = new Point(x,y);
point1 stores the address of the POint object in memory and not the Point object itself


#String Literal

- does not need package import becaus eit is automatically imported
- String is a class and reference type in Java
- String index starts with 0
parameters - the value that is declared in method declaration
arguments - the values pased to the method
- Strings are always immutable in Java
- any operations performed on original string returns a new String

#escape sequence

- \ 
- \n
- \t

#Arrays

- to store list of messages
- it is a reference type
int[] numbers = new int(5);
int[] numbers = {2,3,4,5,6};
- Arrays are of fixed length
- We cannot add or removed items
#sort arrays
- Arrays.sort(numbers);
Arrays.toString((numbers);

#Multidemsional Arrays

int[][] numbers = new int[2][3];
int[][] numbers1 = {{1,2,3},{4,5,6}};
Arrays.deepToString((numbers1);


#Constants

- value cannot be changed
- final keyword

#Order of operator

- ()
- /*
- /+

#Casting 

#implicit casting

- smaller data types automatically gets type casted to bigger types
- eg: short > int

#Explicit casting

- explicitly cast from one compatible type to another

#Wrapper class

- to convert non-compatible types

#Math

- for mathematical calculations

#Number Format

#NumberFormat

- this abstract class is used for formatting numbers
- we need to get the instance for every format type as follows
- for currency

NumberFormat currency =  NumberFormat.getCurrencyInstance();
NumberFormat percent =  NumberFormat.getPercentInstance()
		
#Method Chaining

NumberFormat.getPercentInstance().format(0.1)

- calling one method after another

#Reading Input

- Scanner class


#Operators

#Ternary

- ? :

String className = income > 100_000 ? "First" : "Economy";

- it helps to avoid basic if else conditions

- avoid nested if else statements
- flat structure is clean and easier to read

#Refactoring

- a method should have 5 to 10 lines and not more than 20 lines
- look for repititive and relative code to put inside new methods