#Threads

- JVM has scheduler to decide which thread to run when
- if there are more tasks than the available threads in CPU,it switches between threads

#Process

- An instance of an Application or a Program
- It has some memory and resources
- concurrent processing

#Threads

- sequence of instructions
- main thread and sub threads
- multi threading
- runs parallely

#Pausing Threads

- sleep a thread using Thread.Sleep(5000)

#Join thread

- to make main thread wait for the other thread to finish

eg: File scan thread wait for file download thread to complete\

eg thread.join();

- it makes main thread to wait for 5 seconds

#Interrupting Thread

- thread.interrupt()

- it sends an interrupt signal to the current thread
- we have to check the interrupt condition manually in the other thread

- interrupting a sleeping thread throws exception


#Concurrency Issues

- multiple threads changing same data at same time

#Race Condition

- Threads race to update the data

#Visibility problem

- update from one thread not visible to others

#Thread safe

- can be used across multithreading

#Atomic operation

- cannot break into small steps

#Strategies for thread safety

# 1.Confinement

- dont share data across threads
- let each thread have its own object and combine the result

#2. Immutability

- Sharing immutable threads is ok but it is read only

#3. Synchronization

- using locks
- it is done sequentially instead of parallely
- introduces deadlock and makes application crash

#4. Atomic Objects

- Thread safe using locks
- using a single atomic operation

#5. Paritioning

- partioning data into segments to access data concurrently
- eg: collection


#Locks

Lock - an interface
ReentrantLock - the implementation

lock.lock()
operations...
lock.unlock()

#Synchronized 

- synchronized(totalBytesLock)
- we can also declare a method as synchronized
- avoid synchronized 

#Volatile

- solves visibility problem but not the race condition
- thread always reads the field from main memory instead of the local cache
- the volatile variable is visible across all threads

#wait method

- to make a thread go to sleep before other thread wake sit up

#notify

- to notify a thread to wake up from sleep

#notifyAll

- to notify multiple threads

- dont use these methods for the new code implementations

#Atomic Objects

- java.util.concurrent.atomic

#Adder class

- if a multiple thread access a particular field, user Adder instead of atomic

#Synchronized Collections

- wrapper around a regular collection
Collection<Integer> collection = Collections.synchronizedCollection(new ArrayList<>());
- achieves thread safety using locks
- hence it is slow

#Concurrent Collections

- use partitioning technique to achieve concurrency
- paritions segments and only one thread can access that particular segment at a time
eg: ConcurrentHashMap, CopyOnWriteArrayList

#*******************************************************************************************************
  
#Executor Framework------------------------------

- Simplifies Thread Manipulation but does not prevent synchronization issues

#ThreadPool

- creating and destroying threads is expensive
- pool of threads called worker threads and they are resued to execute tasks
- not destroyed and re-created
- Threadpool resues the threads
- if we create a thread pool with 10 thread and assign 1000 tasks, all tasks will be queued ane executed when threads are available
- so we dont create and manage threads

#ThreadPool Executor

- ExecutorService interface
- Directly creating ThreadPoolExecutor is difficult as it needs lot of params
- so we use factory methods

executor.submit - to assign tasks to the threads

#executor.shutdown()

- to shutdown the executor otherwise it wont stop as it keeps waiting for new tasks

#Callable

- an interface similar to runnable but it returns a value
- it has call method instead of run method which returns a value
- future.get() is a blocking method

- We should not make main thread wait for the other threads

#Asynchronous Programming

- non-blocking way

#CompletableFuture interface
- Every completable future is a future object
- Explicitly complete 
- declarative way using CompletionStage interface
- for complex aysnc operations


#CompletableFuture.runAsync

#CompletableFuture.runAsync()
- no return value (void)

- if we dont pass any params, it will run on common pool //ForkJoinPool.commonPool()
- we can also create a custom pool

#CompletableFuture.supplyAsync
- returns CompletableFuture object


- we can convert an existing sync method to async by wrapping it inside CompletableFuture object


#Run Code on Aync method completion

#CompletionStage interface

- a stage or step in async operations
- provides method to do something once the async operationsa re completed



#Producer Consumer Application

1. Using Locks and Conditions
2. Using wait and notify

#Types of Pools

1. FixedThreadPool

ExecutorService executorService = Executors.newFixedThreadPool(10);
executorService.execute();

- fixed size pool
- using blocking queue 

2. CachedThreadPool

ExecutorService executorService = Executors.newCachedThreadPool();
executorService.execute();

- no fixed threads
- no queue to hold tasks
- uses synchronous queue which has a size of only 1

3. ScheduledThreadPool

- to schedule tasks after certain delay
- uses delay queue
- runs based on execution time

4. SingleThreadedExecutor


#Callable

- method call with a return value

#Future

- placeholder for value which will arrive in future