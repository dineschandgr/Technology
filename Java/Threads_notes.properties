#Threads

- JVM has scheduler to decide which thread to run when
- if there are more tasks than the available threads in CPU,it switches between threads

#Process

- An instance of an Application or a Program
- It has some memory and resources
- concurrent processing

#Threads

- sequence of instructions
- main thread and sub threads
- multi threading
- runs parallely

#Pausing Threads

- sleep a thread using Thread.Sleep(5000)

#Join thread

- to make main thread wait for the other thread to finish

eg: File scan thread wait for file download thread to complete\

eg thread.join();

- it makes main thread to wait for 5 seconds

#Interrupting Thread

- thread.interrupt()

- it sends an interrupt signal to the current thread
- we have to check the interrupt condition manually in the other thread

- interrupting a sleeping thread throws exception


#Concurrency Issues

- multiple threads changing same data at same time

#Race Condition

- Threads race to update the data

#Visibility problem

- update from one thread not visible to others

#Thread safe

- can be used across multithreading

#Atomic operation

- cannot break into small steps

#Strategies for thread safety

# 1.Confinement

- dont share data across threads
- let each thread have its own object and combine the result

#2. Immutability

- Sharing immutable threads is ok but it is read only

#3. Synchronization

- using locks
- it is done sequentially instead of parallely
- introduces deadlock and makes application crash

#4. Atomic Objects

- Thread safe using locks
- using a single atomic operation

#5. Paritioning

- partioning data into segments to access data concurrently
- eg: collection


#Locks

Lock - an interface
ReentrantLock - the implementation

lock.lock()
operations...
lock.unlock()

#Synchronized 

- synchronized(totalBytesLock)
- we can also declare a method as synchronized
- avoid synchronized 

#Volatile

- solves visibility problem but not the race condition
- thread always reads the field from main memory instead of the local cache
- the volatile variable is visible across all threads

#wait method

- to make a thread go to sleep before other thread wake sit up

#notify

- to notify a thread to wake up from sleep

#notifyAll

- to notify multiple threads

- dont use these methods for the new code implementations

#Atomic Objects

- java.util.concurrent.atomic

#Adder class

- if a multiple thread access a particular field, user Adder instead of atomic

#Synchronized Collections

- wrapper around a regular collection
Collection<Integer> collection = Collections.synchronizedCollection(new ArrayList<>());
- achieves thread safety using locks
- hence it is slow

#Concurrent Collections

- use partitioning technique to achieve concurrency
- paritions segments and only one thread can access that particular segment at a time


#Executive Framework------------------------------

#ThreadPool

- creating and destroying threads is expensive
- Threadpool resues the threads
- if we create a thread pool with 10 thread and assign 1000 tasks, all tasks will be queued ane executed when threads are available

#ThreadPool Executor

- ExecutorService interface